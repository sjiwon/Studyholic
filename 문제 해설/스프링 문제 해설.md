# 정답
> <code>트랜잭션 처리</code>가 되지 않는다

<hr>

# 해설
<p>기본적으로 <code>@Transactional</code>은 AOP를 통해서 트랜잭션 처리가 이루어진다</p>

<p>현재 코드상에서 MainService의 Proxy 등록 여부를 살펴보면 다음과 같다</p>

```java
@SpringBootTest
class MainTest{
    @Test
    @DisplayName("MainService Proxy 빈 등록 여부 테스트")
    void test() {
        log.info("isProxy? = {}", AopUtils.isAopProxy(mainService));
        log.info("is CGLIB Proxy? = {}", AopUtils.isCglibProxy(mainService));
        assertThat(AopUtils.isAopProxy(mainService)).isTrue();
        assertThat(AopUtils.isCglibProxy(mainService)).isTrue();
    }
}
```

![CGLIB Proxy](CGLIB%20Proxy%20등록%20여부.png)

<p>MainService는 CGLIB Proxy로 등록되었기 때문에 @Transactional이 동작되기 충분한 상태이다</p>

<p>하지만 결과는 <code>트랜잭션 처리</code>가 이루어지지 않는다</p>

<p>현재 MainService, MainController의 코드는 다음과 같다</p>

```java
// MainController
@Controller
@RequiredArgsConstructor
public class MainController {
    private final MainService mainService;

    public ResponseEntity<Void> transactionalTestMethod() {
        mainService.methodA();
        return ResponseEntity.ok().build();
    }
}

// MainService
@Slf4j
@Service
public class MainService {
    public void methodA() {
        log.info("=== methodA 시작... ===");
        // 비즈니스 로직 A ....
        methodB();
        log.info("=== methodA 종료... ===");
    }

    @Transactional
    public void methodB() {
        log.info("=== methodB 시작... ===");
        // 비즈니스 로직 B ....
        log.info("=== methodB 종료... ===");
    }
}
```

<p>MainController는 현재 MainService를 스프링 빈으로써 주입받고 있고 주입된 MainService는 다음과 같다</p>

![CGLIB Proxy](MainService%20Proxy.png)

<p>보면 CGLIB Proxy로 정상적으로 주입이 되었다</p>

<p>그러나 CGLIB Proxy로써 호출되는 MainService의 methodA는 현재 @Transactional이 없기 때문에 트랜잭션 처리가 되지 않는다</p>

<p>그리고 methodA 내부적으로 methodB를 호출하는데 사실 methodB 앞에는 <code>this</code>가 생략되었고 컴파일된 MainService.class를 보면 다음과 같은 구조로 호출이 된다</p>

![CGLIB Proxy](methodB%20호출.png)

<p>따라서 methodB의 <code>this</code>는 MainService 객체 그 자체를 가리키게 된다</p>

<p>Spring @Transactional은 반드시 Proxy 구조로 앞단에서 시작이 되어야 하지만 this.methodB의 this는 MainService 객체 그 자체이므로 Proxy로 시작이 될 수가 없는 구조이다</p>

> 따라서 이러한 이유로 methodB에는 정상적으로 트랜잭션 처리가 되지 않았던 것이다

<hr>

# 해결방안
<p>질문을 해본 결과 대부분의 사람들은 methodA에 @Transactional을 붙이는 선택을 하게 된다</p>

<p>하지만 이 선택은 절대로 methodB에 트랜잭션 처리를 유도할 수 없다</p>

```java
@Slf4j
@Service
public class MainService {
    @Transactional
    public void methodA() {
        log.info("=== methodA 시작... ===");
        // 비즈니스 로직 A ....
        methodB();
        log.info("=== methodA 종료... ===");
    }

    @Transactional
    public void methodB() {
        log.info("=== methodB 시작... ===");
        // 비즈니스 로직 B ....
        log.info("=== methodB 종료... ===");
    }
}
```

![CGLIB Proxy](트랜잭션%20해결%20실패.png)

<p>언뜻 보면 Transactional이 동작하는것처럼 보이지만 자세히 보면 methodB에는 트랜잭션 처리가 되지 않음을 알 수 있다</p>

<p>위에서 설명한 이유와 동일하게 결국 methodB는 프록시 내부 호출로 인해 트랜잭션 처리가 되지 않는 것이다</p>

<p>이 문제를 해결하려면 다음과 같이 클래스 구조를 변경시켜야 한다</p>

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class MainService {
    private final MainNestedService mainNestedService;

    @Transactional
    public void methodA() {
        log.info("=== methodA 시작... ===");
        // 비즈니스 로직 A ....
        mainNestedService.methodB();
        log.info("=== methodA 종료... ===");
    }
}

@Slf4j
@Service
public class MainNestedService {
    @Transactional
    public void methodB() {
        log.info("=== methodB 시작... ===");
        // 비즈니스 로직 B ....
        log.info("=== methodB 종료... ===");
    }
}
```

<p>이와 같이 methodB의 호출 자체를 다른 Service에 맡기고 해당 Service를 Proxy로 스프링 빈에 등록하는 것이다</p>

![CGLIB Proxy](트랜잭션%20해결%20성공.png)